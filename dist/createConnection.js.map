{"version":3,"file":"createConnection.js","sourceRoot":"","sources":["../src/createConnection.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAC;AACzC,OAAO,EAAE,SAAS,EAAE,WAAW,EAAE,MAAM,EAAE,MAAM,oBAAoB,CAAC;AACpE,OAAO,EACL,eAAe,EACf,OAAO,EACP,kBAAkB,GAInB,MAAM,SAAS,CAAC;AAIjB,OAAO,EAAE,sCAAsC,EAAE,MAAM,sCAAsC,CAAC;AAC9F,OAAO,EAAE,iBAAiB,EAAE,MAAM,qBAAqB,CAAC;AACxD,OAAO,EAAE,mBAAmB,EAAE,MAAM,uBAAuB,CAAC;AAgC5D,MAAM,CAAC,MAAM,gBAAgB,GAAG,KAAK,EAGnC,EACA,MAAM,EACN,KAAK,EACL,KAAK,EACL,WAAW,GAAG,EAAE,EAChB,OAAO,GAAG,EAAE,EACZ,GAAG,GAAG,EAAE,GAUT,EAA0C,EAAE;IAC3C,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAE,CAAC,EAAE,GAAG,OAAO,CAAC;IACnC,GAAG,CAAC,4BAA4B,EAAE,MAAM,CAAC,CAAC;IAC1C,MAAM,UAAU,GAAsB,MAAM,OAAO,CAAC;QAClD,OAAO,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,CAAC,CAAC;QAC5B,aAAa,EAAE,SAAS,CAAC,KAAK,CAAC;YAC7B,CAAC,CAAC,kBAAkB,CAAC,IAAI,WAAW,EAAE,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;YACrD,CAAC,CAAC,SAAS;QACb,KAAK,EAAE,KAAK;KACb,CAAC,CAAC;IACH,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC,WAAW,CAAC,CAAC;IAC5C,GAAG,CAAC,6BAA6B,EAAE,OAAO,CAAC,CAAC;IAC5C,KAAK,MAAM,CAAC,OAAO,EAAE,QAAQ,CAAC,IAAI,OAAO,EAAE,CAAC;QAC1C,IAAI,WAAW,CAAC,QAAQ,CAAC,EAAE,CAAC;YAC1B,SAAS;QACX,CAAC;QACD,sCAAsC,CAAC;YACrC,UAAU;YACV,OAAO;YACP,QAAQ;YACR,OAAO;YACP,GAAG;SACJ,CAAC,CAAC;IACL,CAAC;IAED,OAAO;QACL,UAAU;QACV,WAAW,EAAE,KAAK,EAAsB,KAOvC,EAAE,EAAE;YACH,MAAM,EACJ,OAAO,EACP,OAAO,EACP,OAAO,EACP,OAAO,GAAG,EAAE,EACZ,UAAU,EACV,MAAM,GACP,GAAG,KAAK,CAAC;YACV,MAAM,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,OAAO,EAAkB,CAAC,CAAC;YACvE,MAAM,EAAE,SAAS,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;YAE1C,MAAM,EAAE,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC;YACxC,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;gBACtB,MAAM,YAAY,GAAG,SAAS,IAAI,CAAC,GAAG,EAAE,IAAI,MAAM,CAAC,UAAU,EAAE,EAAE,CAAC;gBAClE,EAAE,EAAE,GAAG,CACL,eAAiD,EACjD,YAAY,CACb,CAAC;gBACF,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE;oBACpC,UAAU,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;gBACnC,CAAC,CAAC,CAAC;YACL,CAAC;YAED,MAAM,QAAQ,GAAG,MAAM,UAAU,CAAC,WAAW,CAC3C,OAAiB,EACjB,UAAU,EACV;gBACE,OAAO,EAAE,SAAS;gBAClB,OAAO,EAAE,EAAE;gBACX,QAAQ,EAAE,eAAe,CAAC,WAAW;aACtC,CACF,CAAC;YACF,IAAI,KAAK,EAAE,MAAM,IAAI,IAAI,QAAQ,EAAE,CAAC;gBAClC,QAAQ,CAAC;gBACT,IAAI,MAAM,EAAE,OAAO,EAAE,CAAC;oBACpB,OAAO;gBACT,CAAC;gBACD,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE,CAAC;oBACzD,MAAM;gBACR,CAAC;gBACD,MAAM,YAAY,GAAG,MAAM,iBAAiB,CAAC;oBAC3C,GAAG,EAAE,IAAI;oBACT,OAAO;oBACP,OAAO;oBACP,GAAG;iBACJ,CAAC,CAAC;gBACH,MAAM,UAAU,CAAC,YAAY,CAAC,CAAC;YACjC,CAAC;QACH,CAAC;QAED,OAAO,EAAE,KAAK,EAAsB,KAKnC,EAA8B,EAAE;YAC/B,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,GAAG,EAAE,EAAE,GAAG,KAAK,CAAC;YAC1D,MAAM,UAAU,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,OAAO,EAAkB,CAAC,CAAC;YACvE,MAAM,EAAE,SAAS,GAAG,EAAE,GAAG,IAAI,EAAE,GAAG,OAAO,CAAC;YAE1C,MAAM,EAAE,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC;YAExC,MAAM,IAAI,GAAG,MAAM,UAAU,CAAC,OAAO,CAAC,OAAiB,EAAE,UAAU,EAAE;gBACnE,OAAO,EAAE,SAAS;gBAClB,OAAO,EAAE,EAAE;aACZ,CAAC,CAAC;YACH,IAAI,WAAW,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,KAAK,CAAC,EAAE,CAAC;gBACzD,OAAO,SAAS,CAAC;YACnB,CAAC;YACD,OAAO,iBAAiB,CAAC,EAAE,GAAG,EAAE,IAAI,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC;QACjE,CAAC;QACD,OAAO,EAAE,KAAK,EAAoD,KAIjE,EAAiB,EAAE;YAClB,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,GAAG,KAAK,CAAC;YAC5C,MAAM,GAAG,GAAG,KAAK,CAAC,SAAS,CAAC,EAAE,KAAK,EAAE,OAAO,EAAkB,CAAC,CAAC;YAEhE,MAAM,EAAE,GAAG,mBAAmB,CAAC,OAAO,CAAC,CAAC;YAExC,OAAO,UAAU,CAAC,OAAO,CAAC,OAAiB,EAAE,GAAG,EAAE;gBAChD,OAAO,EAAE,EAAE;aACZ,CAAC,CAAC;QACL,CAAC;KACF,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import { Bytes } from \"@mjt-engine/byte\";\nimport { isDefined, isUndefined, toMany } from \"@mjt-engine/object\";\nimport {\n  RequestStrategy,\n  connect,\n  credsAuthenticator,\n  type NatsConnection,\n  type Stats,\n  type Status,\n} from \"nats.ws\";\nimport type { ConnectionMap } from \"./type/ConnectionMap\";\nimport type { ConnectionSpecialHeader } from \"./type/ConnectionSpecialHeader\";\nimport type { ConnectionListener } from \"./type/ConnectionListener\";\nimport { connectConnectionListenerToSubjectRoot } from \"./connectConnectionListenerToSubject\";\nimport { msgToResponseData } from \"./msgToResponseData\";\nimport { recordToNatsHeaders } from \"./recordToNatsHeaders\";\nimport type { ValueOrError } from \"./type/ValueOrError\";\nimport type { PartialSubject } from \"./type/PartialSubject\";\nimport type { EventMap } from \"./type/EventMap\";\n\nexport type MessageConnection = NatsConnection;\nexport type MessageConnectionStats = Stats;\nexport type MessageConnectionStatus = Status;\n\nexport type MessageConnectionInstance<CM extends ConnectionMap> = {\n  connection: MessageConnection;\n  requestMany: <S extends keyof CM>(props: {\n    subject: S;\n    request: CM[S][\"request\"];\n    headers?: Record<keyof CM[S][\"headers\"], string>;\n    options?: Partial<{ timeoutMs: number }>;\n    onResponse: (response: CM[S][\"response\"]) => void | Promise<void>;\n    signal?: AbortSignal;\n  }) => Promise<void>;\n  request: <S extends keyof CM>(props: {\n    subject: S;\n    request: CM[S][\"request\"];\n    headers?: Record<keyof CM[S][\"headers\"], string>;\n    options?: Partial<{ timeoutMs: number }>;\n  }) => Promise<CM[S][\"response\"]>;\n  publish: <S extends PartialSubject, EM extends EventMap<S>>(props: {\n    subject: S;\n    payload: EM[S];\n    headers?: Record<keyof CM[S][\"headers\"], string>;\n  }) => Promise<void>;\n};\n\nexport const createConnection = async <\n  CM extends ConnectionMap,\n  E extends Record<string, string> = Record<string, string>\n>({\n  server,\n  creds,\n  token,\n  subscribers = {},\n  options = {},\n  env = {},\n}: {\n  server: string[] | string;\n  subscribers?: Partial<{ [k in keyof CM]: ConnectionListener<CM, k, E> }>;\n  creds?: string;\n  token?: string;\n  options?: Partial<{\n    log: (message: unknown, ...extra: unknown[]) => void;\n  }>;\n  env?: Partial<E>;\n}): Promise<MessageConnectionInstance<CM>> => {\n  const { log = () => {} } = options;\n  log(\"createConnection: server: \", server);\n  const connection: MessageConnection = await connect({\n    servers: [...toMany(server)],\n    authenticator: isDefined(creds)\n      ? credsAuthenticator(new TextEncoder().encode(creds))\n      : undefined,\n    token: token,\n  });\n  const entries = Object.entries(subscribers);\n  log(\"createConnection: entries: \", entries);\n  for (const [subject, listener] of entries) {\n    if (isUndefined(listener)) {\n      continue;\n    }\n    connectConnectionListenerToSubjectRoot({\n      connection,\n      subject,\n      listener,\n      options,\n      env,\n    });\n  }\n\n  return {\n    connection,\n    requestMany: async <S extends keyof CM>(props: {\n      subject: S;\n      request: CM[S][\"request\"];\n      headers?: Record<keyof CM[S][\"headers\"], string>;\n      options?: Partial<{ timeoutMs: number }>;\n      onResponse: (response: CM[S][\"response\"]) => void | Promise<void>;\n      signal?: AbortSignal;\n    }) => {\n      const {\n        request,\n        subject,\n        headers,\n        options = {},\n        onResponse,\n        signal,\n      } = props;\n      const requestMsg = Bytes.toMsgPack({ value: request } as ValueOrError);\n      const { timeoutMs = 60 * 1000 } = options;\n\n      const hs = recordToNatsHeaders(headers);\n      if (isDefined(signal)) {\n        const abortSubject = `abort.${Date.now()}.${crypto.randomUUID()}`;\n        hs?.set(\n          \"abort-subject\" satisfies ConnectionSpecialHeader,\n          abortSubject\n        );\n        signal.addEventListener(\"abort\", () => {\n          connection.publish(abortSubject);\n        });\n      }\n\n      const iterable = await connection.requestMany(\n        subject as string,\n        requestMsg,\n        {\n          maxWait: timeoutMs,\n          headers: hs,\n          strategy: RequestStrategy.SentinelMsg,\n        }\n      );\n      for await (const resp of iterable) {\n        iterable;\n        if (signal?.aborted) {\n          return;\n        }\n        if (isUndefined(resp.data) || resp.data.byteLength === 0) {\n          break;\n        }\n        const responseData = await msgToResponseData({\n          msg: resp,\n          subject,\n          request,\n          log,\n        });\n        await onResponse(responseData);\n      }\n    },\n\n    request: async <S extends keyof CM>(props: {\n      subject: S;\n      request: CM[S][\"request\"];\n      headers?: Record<keyof CM[S][\"headers\"], string>;\n      options?: Partial<{ timeoutMs: number }>;\n    }): Promise<CM[S][\"response\"]> => {\n      const { request, subject, headers, options = {} } = props;\n      const requestMsg = Bytes.toMsgPack({ value: request } as ValueOrError);\n      const { timeoutMs = 60 * 1000 } = options;\n\n      const hs = recordToNatsHeaders(headers);\n\n      const resp = await connection.request(subject as string, requestMsg, {\n        timeout: timeoutMs,\n        headers: hs,\n      });\n      if (isUndefined(resp.data) || resp.data.byteLength === 0) {\n        return undefined;\n      }\n      return msgToResponseData({ msg: resp, subject, request, log });\n    },\n    publish: async <S extends PartialSubject, EM extends EventMap<S>>(props: {\n      subject: S;\n      payload: EM[S];\n      headers?: Record<keyof CM[S][\"headers\"], string>;\n    }): Promise<void> => {\n      const { payload, subject, headers } = props;\n      const msg = Bytes.toMsgPack({ value: payload } as ValueOrError);\n\n      const hs = recordToNatsHeaders(headers);\n\n      return connection.publish(subject as string, msg, {\n        headers: hs,\n      });\n    },\n  };\n};\n"]}