{"version":3,"file":"createConnection.js","sourceRoot":"","sources":["../src/createConnection.ts"],"names":[],"mappings":"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","sourcesContent":["import { Bytes } from \"@mjt-engine/byte\";\nimport { isDefined, isUndefined, toMany } from \"@mjt-engine/object\";\nimport {\n  connect,\n  credsAuthenticator,\n  Msg,\n  RequestStrategy,\n  type NatsConnection,\n  type Stats,\n  type Status,\n} from \"nats.ws\";\nimport {\n  connectConnectionListenerToSubject,\n  DEFAULT_MAX_MESSAGE_SIZE,\n} from \"./connectConnectionListenerToSubject\";\nimport { msgToResponseData } from \"./msgToResponseData\";\nimport { recordToNatsHeaders } from \"./recordToNatsHeaders\";\nimport { ABORT_SUBJECT_HEADER, CHUNK_HEADER } from \"./SPECIAL_HEADERS\";\nimport type { ConnectionListener } from \"./type/ConnectionListener\";\nimport type { ConnectionMap } from \"./type/ConnectionMap\";\nimport type { EventMap } from \"./type/EventMap\";\nimport type { PartialSubject } from \"./type/PartialSubject\";\nimport type { ValueOrError } from \"./type/ValueOrError\";\nimport { Errors } from \"@mjt-engine/error\";\n\nexport type MessageConnection = NatsConnection;\nexport type MessageConnectionStats = Stats;\nexport type MessageConnectionStatus = Status;\n\nexport type MessageConnectionInstance<CM extends ConnectionMap> = {\n  connection: MessageConnection;\n  requestMany: <S extends keyof CM>(props: {\n    subject: S;\n    request: CM[S][\"request\"];\n    headers?: Record<keyof CM[S][\"headers\"], string>;\n    options?: Partial<{ timeoutMs: number }>;\n    onResponse: (response: CM[S][\"response\"]) => void | Promise<void>;\n    signal?: AbortSignal;\n  }) => Promise<void>;\n  request: <S extends keyof CM>(props: {\n    subject: S;\n    request: CM[S][\"request\"];\n    headers?: Record<keyof CM[S][\"headers\"], string>;\n    options?: Partial<{ timeoutMs: number }>;\n  }) => Promise<CM[S][\"response\"]>;\n  publish: <S extends PartialSubject, EM extends EventMap<S>>(props: {\n    subject: S;\n    payload: EM[S];\n    headers?: Record<keyof CM[S][\"headers\"], string>;\n    options?: Partial<{ timeoutMs: number }>;\n    onResponse?: (response: CM[S][\"response\"]) => void | Promise<void>;\n    onError?: (error: unknown) => void;\n    signal?: AbortSignal;\n  }) => Promise<void>;\n};\n\nexport const createConnection = async <\n  CM extends ConnectionMap,\n  E extends Record<string, string> = Record<string, string>\n>({\n  server,\n  creds,\n  token,\n  subscribers = {},\n  options = {},\n  env = {},\n}: {\n  server: string[] | string;\n  subscribers?: Partial<{ [k in keyof CM]: ConnectionListener<CM, k, E> }>;\n  creds?: string;\n  token?: string;\n  options?: Partial<{\n    log: (message: unknown, ...extra: unknown[]) => void;\n    maxMessageSize?: number;\n  }>;\n  env?: Partial<E>;\n}): Promise<MessageConnectionInstance<CM>> => {\n  const { log = () => {}, maxMessageSize = DEFAULT_MAX_MESSAGE_SIZE } = options;\n  log(\"createConnection: server: \", server);\n  const connection: MessageConnection = await connect({\n    servers: [...toMany(server)],\n    authenticator: isDefined(creds)\n      ? credsAuthenticator(new TextEncoder().encode(creds))\n      : undefined,\n    token: token,\n  });\n  const entries = Object.entries(subscribers);\n  log(\"createConnection: entries: \", entries);\n  for (const [subject, listener] of entries) {\n    if (isUndefined(listener)) {\n      continue;\n    }\n    connectConnectionListenerToSubject({\n      connection,\n      subject,\n      listener,\n      options,\n      env,\n    });\n  }\n\n  return {\n    connection,\n    requestMany: async <S extends keyof CM>(props: {\n      subject: S;\n      request: CM[S][\"request\"];\n      headers?: Record<keyof CM[S][\"headers\"], string>;\n      options?: Partial<{ timeoutMs: number; maxMessageSize: number }>;\n      onResponse: (response: CM[S][\"response\"]) => void | Promise<void>;\n      signal?: AbortSignal;\n    }) => {\n      const {\n        request,\n        subject,\n        headers,\n        options = {},\n        onResponse,\n        signal,\n      } = props;\n      const {\n        timeoutMs = 60 * 1000,\n        maxMessageSize = DEFAULT_MAX_MESSAGE_SIZE,\n      } = options;\n      const requestMsg = Bytes.toMsgPack({ value: request } as ValueOrError);\n\n      if (requestMsg.byteLength > maxMessageSize) {\n      }\n\n      const hs = recordToNatsHeaders(headers);\n      if (isDefined(signal)) {\n        const abortSubject = `abort.${Date.now()}.${crypto.randomUUID()}`;\n        hs?.set(ABORT_SUBJECT_HEADER, abortSubject);\n        signal.addEventListener(\"abort\", () => {\n          connection.publish(abortSubject);\n        });\n      }\n\n      const iterable = await connection.requestMany(\n        subject as string,\n        requestMsg,\n        {\n          maxWait: timeoutMs,\n          headers: hs,\n          strategy: RequestStrategy.SentinelMsg,\n        }\n      );\n      const buffer: Msg[] = [];\n      for await (const resp of iterable) {\n        iterable;\n        if (signal?.aborted) {\n          return;\n        }\n        if (isUndefined(resp.data) || resp.data.byteLength === 0) {\n          break;\n        }\n        const chunkHeader = resp.headers?.get(CHUNK_HEADER);\n        if (chunkHeader) {\n          const chunkParts = chunkHeader.split(\"/\");\n          if (chunkParts.length !== 2) {\n            throw Errors.errorToErrorDetail({\n              error: new Error(\"Invalid chunk header format\"),\n              extra: [{ subject, request, headers, options }],\n            });\n          }\n          if (resp.headers?.hasError) {\n            throw Errors.errorToErrorDetail({\n              error: new Error(\"Chunked response has error\"),\n              extra: [{ subject, request, headers, options, resp }],\n            });\n          }\n          const [currentChunk, totalChunks] = chunkParts.map(Number);\n          buffer.length = totalChunks;\n          buffer[currentChunk - 1] = resp;\n          continue;\n        }\n        const responseData = await msgToResponseData({\n          msg: resp,\n          subject,\n          request,\n          log,\n        });\n        await onResponse(responseData);\n      }\n      if (buffer.length > 0) {\n        //recombine the chunks\n        if (buffer.some((msg) => isUndefined(msg))) {\n          throw Errors.errorToErrorDetail({\n            error: new Error(\"Incomplete chunks received\"),\n            extra: [{ subject, request, headers, options, buffer }],\n          });\n        }\n        const combined = new Uint8Array(\n          buffer.reduce((acc, msg) => acc + msg.data.byteLength, 0)\n        );\n        const responseData = await msgToResponseData({\n          msg: { data: combined },\n          subject,\n          request,\n          log,\n        });\n        await onResponse(responseData);\n      }\n    },\n\n    request: async <S extends keyof CM>(props: {\n      subject: S;\n      request: CM[S][\"request\"];\n      headers?: Record<keyof CM[S][\"headers\"], string>;\n      options?: Partial<{ timeoutMs: number }>;\n    }): Promise<CM[S][\"response\"]> => {\n      const { request, subject, headers, options = {} } = props;\n      const requestMsg = Bytes.toMsgPack({ value: request } as ValueOrError);\n      const { timeoutMs = 60 * 1000 } = options;\n\n      const hs = recordToNatsHeaders(headers);\n\n      const resp = await connection.request(subject as string, requestMsg, {\n        timeout: timeoutMs,\n        headers: hs,\n      });\n      if (isUndefined(resp.data) || resp.data.byteLength === 0) {\n        return undefined;\n      }\n      if (resp.headers?.get(CHUNK_HEADER)) {\n        throw Errors.errorToErrorDetail({\n          error: new Error(\n            \"Chunked response recieved. Use requestMany instead.\"\n          ),\n          extra: [{ subject, request, headers, options }],\n        });\n      }\n      return msgToResponseData({ msg: resp, subject, request, log });\n    },\n\n    publish: async <S extends PartialSubject, EM extends EventMap<S>>(props: {\n      subject: S;\n      payload: EM[S];\n      headers?: Record<keyof CM[S][\"headers\"], string>;\n      options?: Partial<{ timeoutMs: number }>;\n      onResponse?: (response: CM[S][\"response\"]) => void | Promise<void>;\n      onError?: (error: unknown) => void;\n      signal?: AbortSignal;\n    }): Promise<void> => {\n      const {\n        payload,\n        subject,\n        headers,\n        onResponse,\n        options = {},\n        signal,\n        onError,\n      } = props;\n      const { timeoutMs = 60 * 1000 } = options;\n      const msg = Bytes.toMsgPack({ value: payload } as ValueOrError);\n      const replySubject = onResponse\n        ? `reply.${subject}.${crypto.randomUUID()}`\n        : undefined;\n      const hs = recordToNatsHeaders(\n        replySubject ? { ...headers, reply: replySubject } : headers\n      );\n\n      if (replySubject && isDefined(onResponse)) {\n        const buffer: Msg[] = [];\n        const subscription = connection.subscribe(replySubject, {\n          callback: async (err, msg) => {\n            if (isDefined(err)) {\n              onError?.(err);\n              return;\n            }\n            if (isUndefined(msg.data) || msg.data.byteLength === 0) {\n              if (buffer.length != 0) {\n                if (buffer.some((m) => isUndefined(m))) {\n                  onError?.(\n                    new Error(\"Incomplete chunks received in response\")\n                  );\n                  return;\n                }\n                const combined = new Uint8Array(\n                  buffer.reduce((acc, m) => acc + m.data.byteLength, 0)\n                );\n                buffer.length = 0; // Clear the buffer after recombining\n                try {\n                  const responseData = await msgToResponseData({\n                    msg: { data: combined },\n                    subject,\n                    request: payload,\n                    log,\n                  });\n                  clearTimeout(timeoutId);\n                  subscription.unsubscribe();\n                  await onResponse(responseData);\n                } catch (e) {\n                  onError?.(e);\n                }\n              }\n              return;\n            }\n            if (msg.headers?.get(CHUNK_HEADER)) {\n              const chunkHeader = msg.headers.get(CHUNK_HEADER);\n              const chunkParts = chunkHeader.split(\"/\");\n              if (chunkParts.length !== 2) {\n                onError?.(\n                  new Error(\"Invalid chunk header format: \" + chunkHeader)\n                );\n                return;\n              }\n              const [currentChunk, totalChunks] = chunkParts.map(Number);\n              buffer.length = totalChunks;\n              buffer[currentChunk - 1] = msg;\n              return;\n            }\n            clearTimeout(timeoutId);\n            subscription.unsubscribe();\n            const responseData = await msgToResponseData({\n              msg,\n              subject,\n              request: payload,\n              log,\n            });\n            await onResponse(responseData);\n          },\n        });\n        const timeoutId = setTimeout(() => {\n          subscription.unsubscribe();\n        }, timeoutMs);\n        if (signal) {\n          if (signal.aborted) {\n            clearTimeout(timeoutId);\n            subscription.unsubscribe();\n            throw new Error(\"Signal already in aborted state\");\n          }\n          signal.addEventListener(\"abort\", () => {\n            clearTimeout(timeoutId);\n            subscription.unsubscribe();\n          });\n        }\n      }\n\n      if (msg.byteLength < maxMessageSize) {\n        return connection.publish(subject as string, msg, {\n          headers: hs,\n        });\n      }\n      const chunkCount = Math.ceil(msg.byteLength / maxMessageSize);\n      const chunks = [];\n      for (let i = 0; i < chunkCount; i++) {\n        const start = i * maxMessageSize;\n        const end = start + maxMessageSize;\n        const chunk = msg.slice(start, end);\n        chunks.push(chunk);\n      }\n      // Publish each chunk separately\n      for (let i = 0; i < chunks.length; i++) {\n        const chunk = chunks[i];\n        const chunkHeader = `${i + 1}/${chunkCount}`;\n        const chunkHeaders = { ...headers, [CHUNK_HEADER]: chunkHeader };\n        connection.publish(subject as string, chunk, {\n          headers: recordToNatsHeaders(chunkHeaders),\n        });\n      }\n    },\n  };\n};\n"]}