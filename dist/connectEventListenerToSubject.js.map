{"version":3,"file":"connectEventListenerToSubject.js","sourceRoot":"","sources":["../src/connectEventListenerToSubject.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,KAAK,EAAE,MAAM,kBAAkB,CAAC;AACzC,OAAO,EAAE,SAAS,EAAE,MAAM,oBAAoB,CAAC;AAO/C,MAAM,CAAC,MAAM,6BAA6B,GAAG,KAAK,EAIhD,EACA,UAAU,EACV,OAAO,EACP,QAAQ,EACR,OAAO,GAAG,EAAE,EACZ,GAAG,GAAG,EAAE,EACR,MAAM,EACN,OAAO,GAAG,CAAC,CAAC,EAAE,EAAE;IACd,OAAO,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;AACpB,CAAC,GAeF,EAAE,EAAE;IACH,MAAM,EAAE,GAAG,GAAG,GAAG,EAAE,GAAE,CAAC,EAAE,KAAK,EAAE,WAAW,EAAE,OAAO,EAAE,GAAG,OAAO,CAAC;IAChE,GAAG,CAAC,0CAA0C,EAAE,OAAO,CAAC,CAAC;IACzD,MAAM,YAAY,GAAG,UAAU,CAAC,SAAS,CAAC,OAAO,EAAE;QACjD,KAAK;QACL,GAAG,EAAE,WAAW;QAChB,OAAO;KACR,CAAC,CAAC;IAEH,IAAI,SAAS,CAAC,MAAM,CAAC,EAAE,CAAC;QACtB,IAAI,MAAM,CAAC,OAAO,EAAE,CAAC;YACnB,YAAY,CAAC,WAAW,EAAE,CAAC;YAC3B,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;QACrD,CAAC;QACD,MAAM,CAAC,gBAAgB,CAAC,OAAO,EAAE,GAAG,EAAE;YACpC,YAAY,CAAC,WAAW,EAAE,CAAC;QAC7B,CAAC,CAAC,CAAC;IACL,CAAC;IAED,IAAI,KAAK,EAAE,MAAM,OAAO,IAAI,YAAY,EAAE,CAAC;QACzC,IAAI,CAAC;YACH,MAAM,YAAY,GAAG,KAAK,CAAC,eAAe,CACxC,OAAO,CAAC,IAAI,CACb,CAAC;YAEF,MAAM,WAAW,GAAG,CAAC,WAAoB,EAAE,EAAE,CAC3C,YAAY,CAAC,WAAW,CAAC,WAAW,CAAC,CAAC;YAExC,IAAI,SAAS,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,CAAC;gBAClC,OAAO,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC;gBAC5B,SAAS;YACX,CAAC;YAED,MAAM,QAAQ,CAAC;gBACb,MAAM,EAAE,YAAY,CAAC,KAAK;gBAC1B,GAAG;gBACH,MAAM;gBACN,WAAW;aACZ,CAAC,CAAC;QACL,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,OAAO,CAAC,KAAK,CAAC,CAAC;QACjB,CAAC;IACH,CAAC;AACH,CAAC,CAAC","sourcesContent":["import { Bytes } from \"@mjt-engine/byte\";\nimport { isDefined } from \"@mjt-engine/object\";\nimport { type NatsConnection } from \"nats.ws\";\nimport type { EventListener } from \"./type/EventListener\";\nimport type { EventMap } from \"./type/EventMap\";\nimport type { PartialSubject } from \"./type/PartialSubject\";\nimport type { ValueOrError } from \"./type/ValueOrError\";\n\nexport const connectEventListenerToSubject = async <\n  S extends PartialSubject,\n  EM extends EventMap<S>,\n  E extends Record<string, string> = Record<string, string>\n>({\n  connection,\n  subject,\n  listener,\n  options = {},\n  env = {},\n  signal,\n  onError = (e) => {\n    options?.log?.(e);\n  },\n}: {\n  subject: string;\n  connection: NatsConnection;\n  listener: EventListener<S, EM, E>;\n  options?: Partial<{\n    queue?: string;\n    maxMessages?: number;\n    timeout?: number;\n    log: (message: unknown, ...extra: unknown[]) => void;\n  }>;\n  env?: Partial<E>;\n  signal?: AbortSignal;\n\n  onError?: (error: unknown) => void;\n}) => {\n  const { log = () => {}, queue, maxMessages, timeout } = options;\n  log(\"connectEventListenerToSubject: subject: \", subject);\n  const subscription = connection.subscribe(subject, {\n    queue,\n    max: maxMessages,\n    timeout,\n  });\n\n  if (isDefined(signal)) {\n    if (signal.aborted) {\n      subscription.unsubscribe();\n      throw new Error(\"Signal already in aborted state\");\n    }\n    signal.addEventListener(\"abort\", () => {\n      subscription.unsubscribe();\n    });\n  }\n\n  for await (const message of subscription) {\n    try {\n      const valueOrError = Bytes.msgPackToObject<ValueOrError<EM[S]>>(\n        message.data\n      );\n\n      const unsubscribe = (maxMessages?: number) =>\n        subscription.unsubscribe(maxMessages);\n\n      if (isDefined(valueOrError.error)) {\n        onError(valueOrError.error);\n        continue;\n      }\n\n      await listener({\n        detail: valueOrError.value,\n        env,\n        signal,\n        unsubscribe,\n      });\n    } catch (error) {\n      onError(error);\n    }\n  }\n};\n"]}